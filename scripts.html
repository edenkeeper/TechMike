<link rel="stylesheet" href="scripts.css">

<!-- Your Scripts Page content here -->
<!-- Scripts Page -->
<header>
  <h1>Scripts Page</h1>
</header>

<main>
  <section>
    <h2>PowerShell Script to stop screensaver</h2>
    <pre class="code-snippet">
      <code>
        # Script sends the F13 key as input to keep conenciton alive
       param($minutes = 9999)

$myShell = New-Object -com "Wscript.Shell"

for ($i = 0; $i -lt $minutes; $i++) {
Start-Sleep -Seconds 30
$myShell.sendkeys("{F13}")
}
      </code>
    </pre>
  </section>
  
  <section>
    <h2>PowerShell Script to get folder list</h2>
    <pre class="code-snippet">
      <code>
        # Script recursively gets folder lists
        Get-ChildItem$Path -Name -attributes D -Recurse > c:\temp\XXX.csv
      </code>
    </pre>
  </section>

  <section>
    <h2>PowerShell Script to get size of every directory under a $startdirectory </h2>
    <pre class="code-snippet">
      <code>
#gets the size ofevery directory under the $startDirectory directory
#can sometimes be alittle slow if a directory has a lot of folders in it
$startDirectory = 'E:\MSSQL\Backups\'
#gets a list offolders under the $startDirectory directory
$directoryItems =Get-ChildItem $startDirectory | Where-Object {$_.PSIsContainer-eq $true} | Sort-Object
#loops throught helist, calculating the size of each directory
foreach ($i in$directoryItems)
{
$subFolderItems = Get-ChildItem$i.FullName -recurse -force | Where-Object{$_.PSIsContainer -eq $false} |Measure-Object -property Length -sum |Select-Object Sum
$i.FullName+ " -- " + "{0:N2}" -f ($subFolderItems.sum / 1GB) + "GB"
}

#taken from https://sqlnuggets.com/using-powershell-to-list-folders-and-sizes/
      </code>
    </pre>
  </section>

 <section>
    <h2>Robocopy Script to Copy everything from source to destination, with switches. </h2>
    <pre class="code-snippet">
      <code>
      
  robocopy "SOURCE" "DESTINATION" /FP /MT:8 /TEE /S /Z /E /COPY:DAT /NP /R:2 /W:2 /A-:SH /LOG+:"DESTINATION\XYZ_robo.txt"
  Pause


****************************
        /FP	include Full Pathname of files in the output.	Outputs the actual full path to each file copied.
        /MT	The multi-threaded parameter helps speed up your file transfers by increasing the number of CPU threads used to transfer files.
        /TEE	output to console window, as well as the log file.	When you use /LOG, the output isn’t returned to the console; 
               it is only displayed in the resultant log file. Use /TEE to create a log file AND display the results in the console.
        /S	copy Subdirectories, but not empty ones.	Robocopy does not copy subdirectories by default.
        /Z	copy files in restartable mode.	Allows Robocopy to pick back up where it left off if an error or connection drop is encountered.
        /E	copy subdirectories, including Empty ones.	Same as /S, but it also copies empty subdirectories. Automatically adds /S into the command.
        /COPY:copyflag[s]	what to COPY for files (default is /COPY:DAT). (copyflags :D=Data, A=Attributes, T=Timestamps). (S=Security=NTFS ACLs, O=Owner info, U=aUditing info).
                          These are the flags to determine what you want to copy. Default is /COPY:DAT.
        /NP	No Progress - don’t display percentage copied.	Robocopy displays the progress of a file copy in percentage format. /NP disables that progress from being displayed.
        /R:n	number of Retries on failed copies: default 1 million.	Number of times that Robocopy retries a failed copy. Not sure why the default is set to 1 million, which seems excessive.
        /W:n	Wait time between retries: default is 30 seconds.	The amount of time Robocopy waits before attempting a retry.
        /A-:[RASHCNET]	Remove the given Attributes from copied files.	Remove Read only, Archive, System, Hidden, Compressed, Not content indexed, Encrypted, Temporary, Offline.
        /LOG+:file	output status to LOG file (append to existing log).	Instead of overwriting the preview log, the output is added to an already existing log.

        
    </code>
    </pre>
  </section>

  <section>
    <h2>PowerShell Script to seperate text document on the timestamp and create seperate text files per day</h2>
    <pre class="code-snippet">
      <code>
        
      # Prompt user for input file
$inputFile = Read-Host "Enter the full path to the input text file"

$outputFolder = Read-Host "Enter the full path to the output folder"
New-Item -ItemType Directory -Force -Path $outputFolder | Out-Null

# Read all lines
$lines = Get-Content $inputFile

#If the line begins (^) with the format [INT,INT/INT,INT/INT INT,INT,INT i.e. dd/mm/yyyy
#read in day month year and then create outfile using year.month.day
       
foreach ($line in $lines) {
if ($line -match '^\[(\d{2})/(\d{2})/(\d{4})') {
            $day = $matches[1]
            $month = $matches[2]
            $year = $matches[3]
            $outputfile= join-path $outputfolder "$Year.$month.$day.txt"
            add-content -path $outputfile -value $line
   }
}        
      </code>
    </pre>
  </section>

 <section>
    <h2>PowerShell Script to check first character is what you expect</h2>
    <pre class="code-snippet">
      <code>
        
# Prompt for input file
$inputFile = Read-Host "Enter the full path to the input text file"

# Check if file exists
if (-not (Test-Path $inputFile)) {
    Write-Host "File not found: $inputFile" -ForegroundColor Red
    exit
}

# Read all lines
$lines = Get-Content $inputFile

# Regex pattern: starts with [dd/mm/yyyy]
$pattern = '^\[(\d{2})/(\d{2})/(\d{4})'

#output title showing what we are looking for
Write-Host "`nLines that do NOT start with [dd/mm/yyyy]:`n" -ForegroundColor Cyan

#output any lines that do not follow the pattern specfied
        
foreach ($line in $lines) {
    if (-not ($line -match $pattern)) {
        Write-Host $line
    }
}

      </code>
    </pre>
  </section>
  
  
</main>
